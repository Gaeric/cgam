#+title: cgam
#+startup: content
#+author: Gaeric
#+HTML_HEAD: <link href="./worg.css" rel="stylesheet" type="text/css">
#+HTML_HEAD: <link href="/static/css/worg.css" rel="stylesheet" type="text/css">
#+OPTIONS: ^:{}
* cgam
  computer graphics and more
** rtow
   book链接: https://raytracing.github.io/books/RayTracingInOneWeekend.html

   使用cpp与rust分别实现rtow

   我花了许多时间来使用cpp实现一个rtow，花在理解该文所阐述的技术原理的时间要比编码的时间长得多。有很多概念我都需要经过推导才能确性它是可使用的，而且即使现在已经完成了final scene，却仍然部分内容有所存疑，比如Defocus Blur。

   这正是用rust重写一遍，review并记录笔记的好时机！

   但是，我需要降低这一事件的优先级，因为我需要首先完整的读完这个系列的三本书藉。我希望能整对整个RT过程有一个清晰直观的解决方案后，再来逐步解决过程中的困惑。
** rtnw
   book: https://raytracing.github.io/books/RayTracingTheNextWeek.html#overview
*** bvh
    采用3.10节bvh划分方法后，渲染时长比3.9节完成的bvh划分后渲染时长更长，这里需要分析问题的原因，并找到bvh划分的良好方法。

    出于项目的进度考虑，在cpp版本中不在此进行深入debug，使用rust重写时再次澄清该节点的问题。
*** perlin noise
    见于wiki： https://en.wikipedia.org/wiki/Perlin_noise

     perlin noise噪声的算法原理没有介绍，此处需要进行深入了解。

     perlin噪声的当前效果与例图无法对应，需要在上一条的基础上找到实现中的错误。

     根据perlin噪声的基本思想，在p点处的噪声值，为其空间中相临整数点的值的线性插值。在该例中，在三维空间中进行计算，于是取了正立方体上的8个顶点，对这8个点进行三线性插值。

     下面来分别拆解noise函数与tralinear_interp三线性插值函数。
**** noise
     #+begin_src c-ts
       double noise(const point3& p) const {
           auto u = p.x() - std::floor(p.x());
           auto v = p.y() - std::floor(p.y());
           auto w = p.z() - std::floor(p.z());

           auto i = int(std::floor(p.x()));
           auto j = int(std::floor(p.y()));
           auto k = int(std::floor(p.z()));

           double c[2][2][2];

           for (int di = 0; di < 2; di++) {
               for (int dj = 0; dj < 2; dj++) {
                   for (int dk = 0; dk < 2; dk++) {
                       c[di][dj][dk] = randfloat[perm_x[(i + di) & 255] ^
                                                 perm_y[(j + dj) & 255] ^
                                                 perm_z[(k + dk) & 255]];
                   }
               }
           }

           return trilinear_interp(c, u, v, w);
       }
     #+end_src
     noise函数接收某个点P，返回噪声函数在点p处理的值。

     首先拿到点P在-x, -y, -z方向的顶点(i, j, k)，并将该点视为原点(0, 0, 0)，则另外七个顶点分别为：
     (i, j, k+1), (i, j+1, k), (i, j+1, k+1), (i+1, j, k), (i+1, j, k+1), (i+1, j+1, k), (i+1, j+1, k+1)

     uvw则为点P相对于(i, j, k)的位置。
     
     perlin噪声插值在[0, 1]范围内进行插值，首先需要取得8个顶点的值，该实现中这8个点查x, y, z轴的随机数表而得，并存储到三维数组c中。

     随后对根据这8个点对P进行三线性插值。
**** trilinear_interp
     #+begin_src c-ts
       static double trilinear_interp(double c[2][2][2], double u, double v, double w) {
           auto accum = 0.0;
           for (int i = 0; i < 2; i++) {
               for (int j = 0; j < 2; j++) {
                   for (int k = 0; k < 2; k++) {
                       accum += (i * u + (1 - i) * (1 - u)) * (j * v + (1 - j) * (1 - v)) *
                                (k * w + (1 - k) * (1 - w)) * c[i][j][k];
                   }
               }
           }
           return accum;
       }
     #+end_src
     本例中，三线性插值的插值函数选用是(1 - t)，对于c[0][0][0]点，其在i轴上的差值分量为：i * u + (1-i)*(1-u)

     简单理解：u值越靠近0点，i轴0点对其值的影响越小，i轴1点对其值的影响越大
